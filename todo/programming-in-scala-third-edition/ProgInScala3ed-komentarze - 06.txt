/\
Advantages of immutable objects:
(6.2;p137)

- no changes over time, so easier to reason about,
- no need to make defensive copies before passing them to other copies,
- no way to corrupt state because of concurrency,
- safe hash table keys.

/\
Disadvantages of immutable objects:
(6.2;p137)

- sometimes requre that a large object graph be copied (vs. in place update).

/\
Discuss the primary constructor.
(6.2;p137)

The Scala compiler will compile any code you place in the class body,
which isn’t part of a field or a method definition, into the primary constructor.

/\
Example of reimplementation the toString method.
(6.3;p138)

class Rational(n: Int, d: Int) {
  override def toString = n + "/" + d
}

/\
Example of definition a precondition of the primary constructor.
(6.4;p139)

class Rational(n: Int, d: Int) {
  require(d != 0) // Predef
}
new Rational(5, 0) // IllegalArgumentException

/\
Compile:
class Rational(n: Int, d: Int)
new Rational(5, 0).n
(6.5;p139)

error: value n is not a member of Rational

/\
Compile:
class Rational(n: Int, d: Int) {
  def add(that: Rational): Rational = new Rational(n * that.d + that.n * d, d * that.d)
}
(6.5;p139)

error: value d is not a member of Rational
error: value n is not a member of Rational

"n" and "d" are only available inside the object where "add" was called.

/\
Correct:
class Rational(n: Int, d: Int) {
  def add(that: Rational): Rational = new Rational(n * that.d + that.n * d, d * that.d)
}
(6.5;p141)

class Rational(val n: Int, val d: Int) {
  def add(that: Rational): Rational = new Rational(n * that.d + that.n * d, d * that.d)
}
or
class Rational(n: Int, d: Int) {
  val numer: Int = n
  val denom: Int = d
  def add(that: Rational): Rational = new Rational(numer * that.denom + that.numer * denom, denom * that.denom)
}

/\
Discuss the keyword "this".
(6.6;p141)

- refers to the object instance.
- auxiliary constructors start with def this(...).

/\
Example an auxiliary constructor.
(6.7;p143)

class Rational(n: Int, d: Int) {
  def this(n: Int) = this(n, 1)
}

/\
Compile:
class Rational(n: Int, d: Int) {
  def this(n: Int) = {
    println ("auxiliary constructor")
    this(n, 1)
  }
}
(6.7;p143)

error: 'this' expected but identifier found.
Every auxiliary constructor must invoke another constructor of the same class as its first action.

/\
Correct:
class Rational(n: Int, d: Int) {
  def this(n: Int) = {
    println ("auxiliary constructor")
    this(n, 1)
  }
}
(6.7;p143)

class Rational(n: Int, d: Int) {
  def this(n: Int) = {
    this(n, 1)
    println ("auxiliary constructor")
  }
}

/\
List of differences between Java and Scala constructors.
(6.7;p143)

Java constructor as its first action can invoke:
- another constructor of the same class,
- a superclass constructor.
Scala constructor as its first action can invoke:
- another constructor of the same class,
- *only the primary constructor* a superclass constructor.

/\
Implement "greatest common divisor".
(6.8;p144)

def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)

/\
Define class with private field and method.
(6.8;p144)

class Foo {
  private val a = 1
  private def foo(a: Int): Int = a + this.a
}

/\
Define operator.
(6.9;p146)

class Foo (val foo: Int) {
  def + (that: Foo):Foo = new Foo(this.foo + that.foo)
  override def toString = foo.toString
}

new Foo(1) + new Foo(2)

/\
Compile:
val $surprise: Int = 1
(6.10;p146)

$surprise: Int = 1
ok, but $ is reserved for identifiers generated by the Scala compiler.

/\
Compile:
val name_: Int = 1
(6.10;p146)

error: illegal start of simple pattern
ok: val name_: : Int = 1

/\
List scala forms of identifiers.
(6.10;p146)

- alphanumeric identifier,
- operator identifier: consists of one or more operator characters,
- mixed identifier: unary_+, myvar_=,
- literal identifier: `for`


/\
Internal representation of identifier :>
(6.10;p149)

$colon$minus$greater

/\
Examples of mixed identifier.
(6.10;p149)

unary_+   a unary + operator
myvar_=   an assignment operator, for properties

/\
Example of implicit conversions.
(6.12;p152)

class Foo (val foo: Int) {
  def + (that: Foo):Foo = new Foo(this.foo + that.foo)
  override def toString = foo.toString
}
implicit def intToFoo(x: Int) = new Foo(x)
1 + new Foo(2)
